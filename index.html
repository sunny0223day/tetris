<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>單頁俄羅斯方塊</title>
  <style>
    :root{
      --bg:#0b0d12;
      --panel:#101522;
      --panel2:#0f1420;
      --text:#e8ecf6;
      --muted:#9aa6c0;
      --border:rgba(255,255,255,.10);
      --shadow: 0 20px 60px rgba(0,0,0,.45);
      --radius: 18px;
      --btn:#141b2a;
      --btnHover:#19223a;
      --btnActive:#0f1524;
      --accent:#6ee7ff;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background: radial-gradient(1000px 600px at 30% 20%, rgba(110,231,255,.10), transparent 50%),
                  radial-gradient(900px 700px at 80% 60%, rgba(167,139,250,.12), transparent 55%),
                  var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans TC", "PingFang TC", "Microsoft JhengHei", Arial, sans-serif;
      letter-spacing:.2px;
    }
    .wrap{
      width:min(980px, 92vw);
      display:grid;
      grid-template-columns: 1fr 320px;
      gap:18px;
    }
    @media (max-width:860px){
      .wrap{ grid-template-columns: 1fr; }
    }
    .card{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:14px 16px;
      border-bottom:1px solid var(--border);
      background: rgba(16,21,34,.55);
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    .title b{font-size:14px}
    .title span{font-size:12px;color:var(--muted)}
    .main{
      display:flex;
      gap:14px;
      padding:16px;
      align-items:flex-start;
    }
    canvas{
      background: radial-gradient(600px 420px at 30% 20%, rgba(110,231,255,.06), transparent 45%),
                  linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.01));
      border:1px solid var(--border);
      border-radius: 14px;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.03);
    }
    .side{
      padding:14px 16px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .stat{
      display:grid;
      grid-template-columns: 1fr auto;
      gap:6px 10px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:14px;
      background: rgba(16,21,34,.35);
    }
    .stat div{font-size:12px;color:var(--muted)}
    .stat b{font-size:18px}
    .divider{
      height:1px;background:var(--border); margin:4px 0;
    }
    .btnrow{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    button{
      appearance:none;
      border:1px solid var(--border);
      background: rgba(20,27,42,.65);
      color:var(--text);
      border-radius:14px;
      padding:10px 12px;
      font-size:13px;
      cursor:pointer;
      transition: transform .06s ease, background .15s ease, border-color .15s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    button:hover{ background: rgba(25,34,58,.75); }
    button:active{ transform: translateY(1px); background: rgba(15,21,36,.75); }
    .primary{
      border-color: rgba(110,231,255,.25);
      box-shadow: 0 0 0 1px rgba(110,231,255,.10) inset;
    }
    .ghost{
      color:var(--muted);
    }

    /* D-pad */
    .pad{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr;
      grid-template-rows: 1fr 1fr 1fr;
      gap:10px;
      padding:12px;
      border:1px solid var(--border);
      border-radius:16px;
      background: rgba(16,21,34,.35);
    }
    .pad button{ padding:12px 0; font-size:14px; }
    .pad .up{ grid-column:2; grid-row:1; }
    .pad .left{ grid-column:1; grid-row:2; }
    .pad .down{ grid-column:2; grid-row:2; }
    .pad .right{ grid-column:3; grid-row:2; }
    .pad .drop{ grid-column:1 / span 3; grid-row:3; }
    .hint{
      font-size:12px; color:var(--muted); line-height:1.5;
      padding:10px 12px;
      border:1px solid var(--border);
      border-radius:14px;
      background: rgba(16,21,34,.30);
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size:11px;
      padding:.15rem .35rem;
      border:1px solid rgba(255,255,255,.14);
      border-radius:8px;
      background: rgba(255,255,255,.06);
      color:#dce6ff;
    }
    .footerActions{
      display:flex; gap:10px; flex-wrap:wrap;
    }
    .small{
      font-size:12px;
      color:var(--muted);
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="header">
        <div class="title">
          <b>俄羅斯方塊</b>
          <span>方向鍵控制，<span class="kbd">Space</span>快速落下。也可用面板按鈕操作。</span>
        </div>
        <div class="footerActions">
          <button id="btnPause" class="ghost">暫停</button>
          <button id="btnRestart" class="primary">重新開始</button>
        </div>
      </div>
      <div class="main">
        <canvas id="game" width="360" height="720" aria-label="tetris"></canvas>
        <div style="display:flex;flex-direction:column;gap:14px;">
          <canvas id="next" width="160" height="160" aria-label="next"></canvas>
          <div class="hint">
            <div style="margin-bottom:6px;"><b style="color:#fff;">快捷鍵</b></div>
            <div>移動：<span class="kbd">←</span> <span class="kbd">→</span></div>
            <div>軟降：<span class="kbd">↓</span></div>
            <div>旋轉：<span class="kbd">↑</span></div>
            <div>快速落下：<span class="kbd">Space</span></div>
          </div>
        </div>
      </div>
    </div>

    <div class="card side">
      <div class="stat">
        <div>分數</div><b id="score">0</b>
        <div>等級</div><b id="level">1</b>
        <div>消行</div><b id="lines">0</b>
      </div>

      <div class="pad">
        <button class="up" id="btnUp">上（旋轉）</button>
        <button class="left" id="btnLeft">左</button>
        <button class="down" id="btnDown">下</button>
        <button class="right" id="btnRight">右</button>
        <button class="drop primary" id="btnDrop">快速落下</button>
      </div>

      <div class="hint">
        <b style="color:#fff;">可替換方塊圖片（7 種）</b><br/>
        在 JS 的 <span class="kbd">SKINS</span> 內改路徑即可：<br/>
        例如 <span class="kbd">skins/I.png</span>、<span class="kbd">skins/T.png</span>...<br/>
        若圖片不存在，會自動用色塊顯示。
      </div>

      <div class="small">
        提示：手機也能玩（觸控按鈕）。桌機建議用鍵盤更順手。<br/>
        （左右鍵/左右按鈕：按一下移一格；按住超過 0.5 秒開始快速移動）
      </div>
    </div>
  </div>

<script>
(() => {
  // ========= 你要換外觀，就改這裡 =========
  // 你可以放本地相對路徑或任何 URL
  const SKINS = {
    I: "images/I.png",
    O: "images/O.png",
    T: "images/T.png",
    S: "images/S.png",
    Z: "images/Z.png",
    J: "images/J.png",
    L: "images/L.png",
  };

  // 預設色塊（當 skin 圖片沒載入或不想用圖片）
  const COLORS = {
    I: "#6ee7ff",
    O: "#ffd56e",
    T: "#c084fc",
    S: "#7cf29a",
    Z: "#ff7a7a",
    J: "#7aa7ff",
    L: "#ffb86b",
    GHOST: "rgba(255,255,255,.10)",
    GRID: "rgba(255,255,255,.06)",
  };

  // ========= 遊戲設定 =========
  const COLS = 10;
  const ROWS = 20;
  const CELL = 36;          // 主畫面每格像素 (canvas 寬=360 高=720)
  const NEXT_CELL = 28;
  const BASE_DROP_MS = 850; // 初速
  const MIN_DROP_MS = 120;  // 最高速上限
  const SPEEDUP_PER_LEVEL = 0.88; // 等級每升，速度乘上這個

  // NEW: 左右長按設定（0.3 秒後才開始快速移動）
  const HOLD_TO_REPEAT_MS = 200;  // 0.5 秒
  const REPEAT_MS = 40;           // 快速移動速度（越小越快）

  // 俄羅斯方塊基本形狀（4x4 或 3x3）
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [1,1],
      [1,1],
    ],
    T: [
      [0,1,0],
      [1,1,1],
      [0,0,0],
    ],
    S: [
      [0,1,1],
      [1,1,0],
      [0,0,0],
    ],
    Z: [
      [1,1,0],
      [0,1,1],
      [0,0,0],
    ],
    J: [
      [1,0,0],
      [1,1,1],
      [0,0,0],
    ],
    L: [
      [0,0,1],
      [1,1,1],
      [0,0,0],
    ],
  };

  const PIECES = Object.keys(SHAPES);

  // NEW: 7-bag 隨機（每 7 個必定各一種）
  let bag = [];
  function shuffle(arr){
    for (let i = arr.length - 1; i > 0; i--){
      const j = (Math.random() * (i + 1)) | 0;
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }
  function nextFromBag(){
    if (bag.length === 0) bag = shuffle(PIECES.slice());
    return bag.pop();
  }

  // ========= Canvas =========
  const c = document.getElementById("game");
  const ctx = c.getContext("2d");
  const nextC = document.getElementById("next");
  const nextCtx = nextC.getContext("2d");

  // ========= UI =========
  const $score = document.getElementById("score");
  const $level = document.getElementById("level");
  const $lines = document.getElementById("lines");
  const btnRestart = document.getElementById("btnRestart");
  const btnPause = document.getElementById("btnPause");

  // 控制按鈕
  const btnLeft = document.getElementById("btnLeft");
  const btnRight = document.getElementById("btnRight");
  const btnDown = document.getElementById("btnDown");
  const btnUp = document.getElementById("btnUp");
  const btnDrop = document.getElementById("btnDrop");

  // ========= 圖片快取（可替換外觀） =========
  const skinImages = {};
  for (const k of PIECES) {
    const img = new Image();
    img.src = SKINS[k] || "";
    img.onload = () => { skinImages[k] = img; };
    img.onerror = () => { /* 失敗就用色塊 */ };
  }

  // ========= 狀態 =========
  let board, cur, next;
  let score = 0, lines = 0, level = 1;
  let dropMs = BASE_DROP_MS;
  let lastTime = 0;
  let acc = 0;
  let paused = false;
  let gameOver = false;

  function newBoard() {
    return Array.from({length: ROWS}, () => Array(COLS).fill(null));
  }

  function cloneMatrix(m) {
    return m.map(r => r.slice());
  }

  function randomPiece() {
    const type = nextFromBag(); // NEW: 7-bag
    const shape = cloneMatrix(SHAPES[type]);
    return {
      type,
      shape,
      x: ((COLS - shape[0].length) / 2) | 0,
      y: -1, // 讓生成更自然
    };
  }

  function rotate(matrix) {
    // clockwise
    const h = matrix.length;
    const w = matrix[0].length;
    const res = Array.from({length:w}, () => Array(h).fill(0));
    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        res[x][h-1-y] = matrix[y][x];
      }
    }
    return res;
  }

  function collides(piece, dx=0, dy=0, newShape=null) {
    const shape = newShape || piece.shape;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const nx = piece.x + x + dx;
        const ny = piece.y + y + dy;
        if (nx < 0 || nx >= COLS || ny >= ROWS) return true;
        if (ny >= 0 && board[ny][nx]) return true;
      }
    }
    return false;
  }

  function merge(piece) {
    const {shape, type} = piece;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const bx = piece.x + x;
        const by = piece.y + y;
        if (by >= 0) board[by][bx] = type;
      }
    }
  }

  function clearLines() {
    let cleared = 0;
    outer: for (let y=ROWS-1; y>=0; y--){
      for (let x=0; x<COLS; x++){
        if (!board[y][x]) continue outer;
      }
      // full row
      board.splice(y, 1);
      board.unshift(Array(COLS).fill(null));
      cleared++;
      y++; // re-check same index after shift
    }

    if (cleared > 0) {
      // 經典計分（可自行調）
      const lineScores = [0, 100, 300, 500, 800];
      score += lineScores[cleared] * level;
      lines += cleared;

      // 每 10 行升級
      const newLevel = 1 + Math.floor(lines / 10);
      if (newLevel !== level) {
        level = newLevel;
        dropMs = Math.max(MIN_DROP_MS, Math.floor(BASE_DROP_MS * Math.pow(SPEEDUP_PER_LEVEL, level-1)));
      }
      syncUI();
    }
  }

  function syncUI() {
    $score.textContent = score;
    $lines.textContent = lines;
    $level.textContent = level;
  }

  function spawn() {
    cur = next || randomPiece();
    next = randomPiece();
    // 若一生成就碰撞 -> Game Over
    if (collides(cur, 0, 0)) {
      gameOver = true;
    }
  }

  function hardDrop() {
    if (paused || gameOver) return;
    let dist = 0;
    while (!collides(cur, 0, 1)) {
      cur.y++;
      dist++;
    }
    // 硬降給一點分數
    score += dist * 2;
    syncUI();
    lock();
  }

  function softDrop() {
    if (paused || gameOver) return;
    if (!collides(cur, 0, 1)) {
      cur.y++;
      score += 1; // 軟降小加分
      syncUI();
    } else {
      lock();
    }
  }

  function move(dx) {
    if (paused || gameOver) return;
    if (!collides(cur, dx, 0)) cur.x += dx;
  }

  function rotateCur() {
    if (paused || gameOver) return;
    const rotated = rotate(cur.shape);

    // 簡易 wall-kick：嘗試左右挪動來塞進去
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks) {
      if (!collides(cur, k, 0, rotated)) {
        cur.shape = rotated;
        cur.x += k;
        return;
      }
    }
  }

  function lock() {
    merge(cur);
    clearLines();
    spawn();
    // 每次落地也給一點分數
    score += 5;
    syncUI();
  }

  // ========= 繪製 =========
  function drawGrid(ctx2, w, h, cell) {
    ctx2.save();
    ctx2.strokeStyle = COLORS.GRID;
    ctx2.lineWidth = 1;
    for (let x=0; x<=w; x+=cell) {
      ctx2.beginPath(); ctx2.moveTo(x+0.5, 0); ctx2.lineTo(x+0.5, h); ctx2.stroke();
    }
    for (let y=0; y<=h; y+=cell) {
      ctx2.beginPath(); ctx2.moveTo(0, y+0.5); ctx2.lineTo(w, y+0.5); ctx2.stroke();
    }
    ctx2.restore();
  }

  function drawCell(ctx2, x, y, cell, type, alpha=1) {
    const px = x * cell;
    const py = y * cell;

    const img = skinImages[type];
    if (img && img.complete && img.naturalWidth > 0) {
      ctx2.save();
      ctx2.globalAlpha = alpha;
      // 讓圖片有一點內縮邊距，看起來更現代
      const pad = Math.max(2, Math.floor(cell * 0.08));
      ctx2.drawImage(img, px + pad, py + pad, cell - pad*2, cell - pad*2);
      ctx2.restore();
      return;
    }

    // fallback：色塊 + 內陰影
    ctx2.save();
    ctx2.globalAlpha = alpha;
    ctx2.fillStyle = COLORS[type] || "#ffffff";
    const r = Math.max(6, Math.floor(cell * 0.18));
    roundRect(ctx2, px+2, py+2, cell-4, cell-4, r);
    ctx2.fill();

    // highlight
    ctx2.globalAlpha = alpha * 0.35;
    ctx2.fillStyle = "rgba(255,255,255,.8)";
    roundRect(ctx2, px+5, py+5, cell-10, Math.max(6, Math.floor(cell*0.22)), r);
    ctx2.fill();

    // border
    ctx2.globalAlpha = alpha * 0.45;
    ctx2.strokeStyle = "rgba(255,255,255,.25)";
    ctx2.lineWidth = 1;
    roundRect(ctx2, px+2.5, py+2.5, cell-5, cell-5, r);
    ctx2.stroke();
    ctx2.restore();
  }

  function roundRect(ctx2, x, y, w, h, r) {
    const rr = Math.min(r, w/2, h/2);
    ctx2.beginPath();
    ctx2.moveTo(x+rr, y);
    ctx2.arcTo(x+w, y, x+w, y+h, rr);
    ctx2.arcTo(x+w, y+h, x, y+h, rr);
    ctx2.arcTo(x, y+h, x, y, rr);
    ctx2.arcTo(x, y, x+w, y, rr);
    ctx2.closePath();
  }

  function drawBoard() {
    ctx.clearRect(0,0,c.width,c.height);

    // grid
    drawGrid(ctx, c.width, c.height, CELL);

    // board blocks
    for (let y=0; y<ROWS; y++){
      for (let x=0; x<COLS; x++){
        const t = board[y][x];
        if (t) drawCell(ctx, x, y, CELL, t, 1);
      }
    }

    // ghost piece (預覽落點)
    if (!gameOver && cur) {
      const ghostY = getGhostY(cur);
      drawPiece(cur, 0, ghostY - cur.y, 0.18, true);
    }

    // current piece
    if (!gameOver && cur) drawPiece(cur, 0, 0, 1, false);

    if (paused) overlayText("暫停", "按「暫停」或按一下畫面繼續");
    if (gameOver) overlayText("遊戲結束", "按「重新開始」再玩一次");
  }

  function overlayText(title, sub) {
    ctx.save();
    ctx.fillStyle = "rgba(0,0,0,.55)";
    ctx.fillRect(0,0,c.width,c.height);

    ctx.fillStyle = "rgba(255,255,255,.92)";
    ctx.font = "700 34px ui-sans-serif, system-ui";
    ctx.textAlign = "center";
    ctx.fillText(title, c.width/2, c.height/2 - 10);

    ctx.fillStyle = "rgba(255,255,255,.70)";
    ctx.font = "14px ui-sans-serif, system-ui";
    ctx.fillText(sub, c.width/2, c.height/2 + 20);
    ctx.restore();
  }

  function getGhostY(piece) {
    let y = piece.y;
    while (!collides(piece, 0, (y - piece.y) + 1)) y++;
    return y;
  }

  function drawPiece(piece, dx, dy, alpha, ghost) {
    const shape = piece.shape;
    for (let y=0; y<shape.length; y++){
      for (let x=0; x<shape[y].length; x++){
        if (!shape[y][x]) continue;
        const bx = piece.x + x + dx;
        const by = piece.y + y + dy;
        if (by < 0) continue;
        drawCell(ctx, bx, by, CELL, piece.type, alpha);
      }
    }
  }

  function drawNext() {
    nextCtx.clearRect(0,0,nextC.width,nextC.height);
    // 背景格線（淡）
    drawGrid(nextCtx, nextC.width, nextC.height, NEXT_CELL);

    if (!next) return;

    const shape = next.shape;
    const w = shape[0].length;
    const h = shape.length;

    // 置中
    const offsetX = Math.floor((nextC.width / NEXT_CELL - w) / 2);
    const offsetY = Math.floor((nextC.height / NEXT_CELL - h) / 2);

    for (let y=0; y<h; y++){
      for (let x=0; x<w; x++){
        if (!shape[y][x]) continue;
        drawCell(nextCtx, offsetX + x, offsetY + y, NEXT_CELL, next.type, 1);
      }
    }
  }

  // ========= 主迴圈 =========
  function tick(t) {
    requestAnimationFrame(tick);
    if (paused || gameOver) {
      drawBoard();
      drawNext();
      return;
    }
    const dt = t - lastTime;
    lastTime = t;
    acc += dt;

    while (acc >= dropMs) {
      acc -= dropMs;
      // 自動落下
      if (!collides(cur, 0, 1)) cur.y++;
      else lock();
      if (gameOver) break;
    }

    drawBoard();
    drawNext();
  }

  // ========= 控制（鍵盤 + 按鈕） =========

  // NEW: 支援「按住 0.5 秒才開始連發」
  function bindButton(btn, handler, { repeat = false } = {}) {
    // click
    btn.addEventListener("click", (e) => { e.preventDefault(); handler(); });

    let holdTimer = null;
    let repeatTimer = null;

    const start = (e) => {
      e.preventDefault();
      handler(); // 一開始先走一格

      if (!repeat) return;

      holdTimer = setTimeout(() => {
        repeatTimer = setInterval(handler, REPEAT_MS);
      }, HOLD_TO_REPEAT_MS);
    };

    const end = () => {
      clearTimeout(holdTimer);
      clearInterval(repeatTimer);
      holdTimer = null;
      repeatTimer = null;
    };

    btn.addEventListener("pointerdown", start);
    btn.addEventListener("pointerup", end);
    btn.addEventListener("pointercancel", end);
    btn.addEventListener("pointerleave", end);
  }

  // 左右：按住 0.5 秒後才開始快速移動
  bindButton(btnLeft,  () => move(-1), { repeat: true });
  bindButton(btnRight, () => move(1),  { repeat: true });

  // 其他維持原本（按一下做一次）
  bindButton(btnDown, () => softDrop(), { repeat: false });
  bindButton(btnUp,   () => rotateCur(), { repeat: false });
  bindButton(btnDrop, () => hardDrop(), { repeat: false });

  // NEW: 鍵盤左右鍵「按住超過 0.5s 才開始連發」
  const keyState = {
    left:  { down:false, hold:null, repeat:null },
    right: { down:false, hold:null, repeat:null },
  };

  function startKeyRepeat(dir) {
    const st = keyState[dir];
    if (st.down) return;
    st.down = true;

    // 先走一格
    move(dir === "left" ? -1 : 1);

    // 0.5 秒後才開始快速連發
    st.hold = setTimeout(() => {
      st.repeat = setInterval(() => {
        move(dir === "left" ? -1 : 1);
      }, REPEAT_MS);
    }, HOLD_TO_REPEAT_MS);
  }

  function stopKeyRepeat(dir) {
    const st = keyState[dir];
    st.down = false;
    clearTimeout(st.hold);
    clearInterval(st.repeat);
    st.hold = null;
    st.repeat = null;
  }

  window.addEventListener("keydown", (e) => {
    const k = e.code;
    if (["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","Space"].includes(k)) e.preventDefault();

    if (k === "ArrowLeft") startKeyRepeat("left");
    else if (k === "ArrowRight") startKeyRepeat("right");
    else if (k === "ArrowDown") {
      if (!e.repeat) softDrop();
    }
    else if (k === "ArrowUp") {
      if (!e.repeat) rotateCur();
    }
    else if (k === "Space") {
      if (!e.repeat) hardDrop();
    }
  }, {passive:false});

  window.addEventListener("keyup", (e) => {
    const k = e.code;
    if (k === "ArrowLeft") stopKeyRepeat("left");
    else if (k === "ArrowRight") stopKeyRepeat("right");
  });

  // 避免切換視窗後卡住
  window.addEventListener("blur", () => {
    stopKeyRepeat("left");
    stopKeyRepeat("right");
  });

  // ========= 暫停 / 重新開始 =========
  function restart() {
    board = newBoard();
    score = 0; lines = 0; level = 1;
    dropMs = BASE_DROP_MS;
    paused = false;
    gameOver = false;

    bag = []; // NEW: 重置 7-bag（避免上一局剩餘順序影響新局）

    next = randomPiece();
    spawn();
    lastTime = performance.now();
    acc = 0;
    syncUI();
    btnPause.textContent = "暫停";
  }

  function togglePause() {
    if (gameOver) return;
    paused = !paused;
    btnPause.textContent = paused ? "繼續" : "暫停";
  }

  btnRestart.addEventListener("click", restart);
  btnPause.addEventListener("click", togglePause);

  // 點 canvas 也可暫停/繼續（方便）
  c.addEventListener("click", () => togglePause());

  // ========= 初始化 =========
  restart();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
